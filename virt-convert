#!/usr/bin/python 
#
# Convert a VMware(tm) virtual machine into an XML image description
#
# Copyright 2008  Red Hat, Inc.
# Joey Boggs <jboggs@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301 USA.

import sys
import os
import logging
import errno
from optparse import OptionParser

import virtinst.cli as cli
import virtinst.util as util
import virtconv
import virtconv.formats as formats
import virtconv.vmcfg as vmcfg
import virtconv.diskcfg as diskcfg

def parse_args():
    """Parse and verify command line."""
    opts = OptionParser()
    opts.set_usage("%prog [options] inputdir|input.vmx "
        "[outputdir|output.xml]")
    opts.add_option("-q", "--quiet", action="store_true", dest="quiet",
                    help=("Don't be verbose"))
    opts.add_option("-a", "--arch", type="string", dest="arch",
                    default=util.get_default_arch(),
                    help=("Machine Architecture Type (i686/x86_64/ppc)"))
    opts.add_option("-t", "--type", type="string", dest="type",
                    help=("Output virtualization type (hvm, paravirt"))
    opts.add_option("-d", "--debug", action="store_true", dest="debug",
                    help=("Print debugging information"))
    opts.add_option("-i", "--input-format", action="store",
                    dest="input_format", default="vmx",
                    help=("Input format, e.g. 'vmx'"))
    opts.add_option("-o", "--output-format", action="store",
                    dest="output_format", default="virt-image",
                    help=("Output format, e.g. 'virt-image'"))
    opts.add_option("-v", "--hvm", action="store_true", dest="fullvirt",
                    help=("This guest should be a fully virtualized guest"))
    opts.add_option("-p", "--paravirt", action="store_true", dest="paravirt",
                    help=("This guest should be a paravirtualized guest"))

    (options, args) = opts.parse_args()
    if len(args) < 1:
        opts.error(("You need to provide an input VM definition"))
    if len(args) > 2:
        opts.error(("Too many arguments provided"))
    
    # hard-code for now
    if options.input_format != "vmx":
        opts.error(("Unsupported input format \"%s\"" % options.input_format))
    if options.output_format != "virt-image":
        opts.error(("Unsupported output format \"%s\""
            % options.output_format))
    if os.path.isdir(args[0]):
        vmx_files = [x for x in os.listdir(args[0]) if x.endswith(".vmx") ]
        if (len(vmx_files)) == 0:
            opts.error(("No VM definition file was found in %s" % args[0]))
        if (len(vmx_files)) > 1:
            opts.error(("Too many .vmx definitions found in %s" % args[0]))
        options.input_file = os.path.join(args[0], vmx_files[0])
        options.input_dir =  args[0]
    else:
        options.input_file = args[0]
        options.input_dir = os.path.dirname(os.path.realpath(args[0]))

    if len(args) == 1:
        options.output_file = None
        options.output_dir = None
        if os.path.isdir(args[0]):
            options.output_dir = options.input_dir
    elif os.path.isdir(args[1]) or args[1].endswith("/"):
        options.output_file = None
        options.output_dir = args[1]
    else:
        options.output_file = args[1]
        options.output_dir = os.path.dirname(os.path.realpath(args[1]))

    return options

def verbose(options, msg):
    """Output a message if --quiet is not set."""
    if not options.quiet:
        print msg

def cleanup(msg, options, vmdef, paths):
    """
    After failure, clean up anything we created.
    """
    logging.error(msg)

    try:
        paths.reverse()
        for path in paths:
            if os.path.isdir(path):
                os.rmdir(path)
            elif os.path.isfile(path):
                os.remove(path)

        for disk in vmdef.disks:
            disk.cleanup()
    except OSError, e:
        logging.error("Couldn't clean up output directory \"%s\": %s" %
            (options.output_dir, e.strerror))

    sys.exit(1)

def main():
    options = parse_args()
    cli.setupLogging("virt-convert", options.debug)

    try:
        inp = formats.find_parser_by_name(options.input_format)
    except:
        logging.error("No parser of format \"%s\" was found." %
            options.input_format)
        sys.exit(1)
 
    try:
        outp = formats.find_parser_by_name(options.output_format)
    except:
        logging.error("No parser of format \"%s\" was found." %
            options.output_format)
        sys.exit(1)

    vmdef = None

    try:
        vmdef = inp.import_file(options.input_file)
    except IOError, e:
        logging.error("Couldn't import file \"%s\": %s" %
            (options.input_file, e.strerror))
        sys.exit(1)
    except Exception, e:
        logging.error("Couldn't import file \"%s\": %s" %
            (options.input_file, e.message))
        sys.exit(1)

    if options.paravirt:
        vmdef.type = vmcfg.VM_TYPE_PV
    else:
        vmdef.type = vmcfg.VM_TYPE_HVM

    vmdef.arch = options.arch

    clean = []

    unixname = vmdef.name.replace(" ", "-")

    if not options.output_dir:
        options.output_dir = unixname
    try:
        logging.debug("Creating directory %s" % options.output_dir)
        clean += [ options.output_dir ]
        os.mkdir(options.output_dir)
    except OSError, e:
        if (e.errno != errno.EEXIST):
            logging.error("Could not create directory %s: %s" %
                (options.output_dir, e.strerror))
            sys.exit(1)

    if not options.output_file:
        options.output_file = os.path.join(options.output_dir,
           "%s%s" % (unixname, outp.suffix))

    logging.debug("input_file: %s" % options.input_file)
    logging.debug("input_dir: %s" % options.input_dir)
    logging.debug("output_file: %s" % options.output_file)
    logging.debug("output_dir: %s" % options.input_dir)

    verbose(options, "Generating output in \"%s\" format to %s/" %
        (options.output_format, options.output_dir))

    try:
        for d in vmdef.disks:
            verbose(options, "Converting disk \"%s\" to type %s..." %
                (d.path, "raw"))
            d.convert(options.input_dir, options.output_dir, "raw")
    except OSError, e:
        cleanup("Couldn't convert disks: %s" % e.strerror,
            options, vmdef, clean)
    except RuntimeError, e:
        cleanup("Couldn't convert disks: %s" % e.message, options, vmdef, clean)

    try:
        clean += [ options.output_file ]
        outp.export_file(vmdef, options.output_file)
    except ValueError, e:
        cleanup("Couldn't export to file \"%s\": %s" %
            (options.output_file, e.message), options, vmdef, clean)

    verbose(options, "Done.")

    
if __name__ == "__main__":
    try:
        main()
    except SystemExit, e:
        sys.exit(e.code)
    except KeyboardInterrupt, e:
        print >> sys.stderr, "Aborted at user request"
    except Exception, e:
        logging.exception(e)
        sys.exit(1)

