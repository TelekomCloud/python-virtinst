#!/usr/bin/python -tt
#
# Copyright(c) FUJITSU Limited 2007.
#
# Script to set up an cloning guest configuration and kick off an cloning
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free  Software Foundation; either version 2 of the License, or 
# (at your option)  any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


import os, sys, string
from optparse import OptionParser, OptionValueError
import subprocess
import libxml2
import logging
import logging.handlers
import libvirt
import virtinst
import virtinst.CloneManager as clmgr

import gettext
import locale

locale.setlocale(locale.LC_ALL, '')
gettext.bindtextdomain(virtinst.gettext_app, virtinst.gettext_dir)
gettext.install(virtinst.gettext_app, virtinst.gettext_dir)

MIN_RAM = 256
MAX_LOGSIZE   = 1024 * 1024  # 1MB
ROTATE_NUM    = 5
DIR_NAME      = ".virtinst"
FILE_NAME     = "virt-clone.log"
FILE_MODE     = 'a'
FILE_FORMAT   = "[%(asctime)s virt-clone %(process)d] %(levelname)s (%(module)s:%(lineno)d) %(message)s"
STREAM_FORMAT = "%(asctime)s %(levelname)-8s %(message)s"
DATEFMT       = "%a, %d %b %Y %H:%M:%S"

# set up logging
vi_dir = os.path.expanduser("~/%s" % DIR_NAME)
if not os.access(vi_dir,os.W_OK):
    try:
        os.mkdir(vi_dir)
    except IOError, e:
        raise RuntimeError, _("Could not create %d directory: ") % vi_dir, e

filename = "%s/%s" % (vi_dir, FILE_NAME)
rootLogger = logging.getLogger()
rootLogger.setLevel(logging.DEBUG)
fileHandler = logging.handlers.RotatingFileHandler(filename, FILE_MODE, MAX_LOGSIZE, ROTATE_NUM)
fileHandler.setFormatter(logging.Formatter(FILE_FORMAT, DATEFMT))
rootLogger.addHandler(fileHandler)


### Utility functions
def prompt_for_input(prompt = "", val = None):
    if val is not None:
        return val
    print prompt + " ",
    return sys.stdin.readline().strip()

### General input gathering functions
def get_clone_name(new_name, design):
    while 1:
        new_name = prompt_for_input(_("What is the name for the cloned virtual machine?"), new_name)
        try:
            design.clone_name = new_name
            break
        except (ValueError, RuntimeError), e:
            print _("ERROR: "), e
            new_name = None

def get_original_guest(guest, design):
    while 1:
        guest = prompt_for_input(_("What is the name or uuid of the original virtual machine?"), guest)
        try:
            design.original_guest = guest
            break
        except (ValueError, RuntimeError), e:
            print _("ERROR: "), e
            guest = None

def get_clone_macaddr(new_mac, design):
    if new_mac is None:
        pass
    elif new_mac[0] == "RANDOM":
        new_mac = None
    else:
        for i in new_mac:
            design.set_clone_mac(i)

def get_clone_uuid(new_uuid, design):
    if new_uuid is not None:
        design.set_clone_uuid(new_uuid)

def get_clone_diskfile(new_diskfile, design):
    if new_diskfile is None:
        raise ValueError, _("A new disk image file for the cloned guest is required")
    for i in new_diskfile:
        design.set_clone_devices(i) 

def get_clone_sparse(sparse, design):
    design.set_clone_sparse(sparse)

def get_preserve(preserve, design):
    design.set_preserve(preserve)


def get_force_target(target, design):
    if target is None:
        pass
    else:
        for i in target:
            design.set_force_target(i)

### Option parsing
def check_before_store(option, opt_str, value, parser):
    if len(value) == 0:
        raise OptionValueError, _("%s option requires an argument") %opt_str
    setattr(parser.values, option.dest, value)

def check_before_append(option, opt_str, value, parser):
    if len(value) == 0:
        raise OptionValueError, _("%s option requires an argument") %opt_str
    parser.values.ensure_value(option.dest, []).append(value)

def parse_args():
    parser = OptionParser()

    # original name
    parser.add_option("-o", "--original", type="string", dest="original_guest",
                      action="callback", callback=check_before_store,
                      help=_("Name or uuid for the original guest; The status must be shut off"))
    # clone new name
    parser.add_option("-n", "--name", type="string", dest="new_name",
                      action="callback", callback=check_before_store,
                      help=_("Name for the new guest"))

    # clone new uuid
    parser.add_option("-u", "--uuid", type="string",
                      dest="new_uuid", action="callback", callback=check_before_store,
                      help=_("New UUID for the clone guest; Default is a randomly generated UUID"))

    # clone new macs
    parser.add_option("-m", "--mac", type="string",
                      dest="new_mac", action="callback", callback=check_before_append,
                      help=_("New fixed MAC address for the clone guest. Default is a randomly generated MAC"))

    # clone new disks 
    parser.add_option("-f", "--file", type="string",
                      dest="new_diskfile", action="callback", callback=check_before_append,
                      help=_("New file to use as the disk image for the new guest"))
    # connect
    parser.add_option("", "--connect", type="string",
                      dest="connect", action="callback", callback=check_before_store,
                      help=_("Connect to hypervisor with URI"),
                      default=virtinst.util.default_connection())

    # target
    parser.add_option("", "--force-copy", type="string",
                      dest="target", action="callback", callback=check_before_append,
                      help=_("Force to copy devices (eg, if 'hdc' is a readonly cdrom device, --force-copy=hdc)"))

    # non sparse
    parser.add_option("", "--nonsparse", action="store_false",
                      default=True, dest="sparse",
                      help=_("Do not use a sparse file for the clone's disk image"))

    # preserve
    parser.add_option("", "--preserve-data", action="store_false",
                      default=True, dest="preserve",
                      help=_("Preserve a new file to use as the disk image for the new guest"))

    # Misc options
    parser.add_option("-d", "--debug", action="store_true", dest="debug",
                      help=_("Print debugging information"))

    (options,args) = parser.parse_args()
    return options

### Let's do it!
def main():
    options = parse_args()

    streamHandler = logging.StreamHandler(sys.stderr)
    streamHandler.setFormatter(logging.Formatter(STREAM_FORMAT, DATEFMT))
    if options.debug:
        streamHandler.setLevel(logging.DEBUG)
    else:
        streamHandler.setLevel(logging.ERROR)
    rootLogger.addHandler(streamHandler)

    logging.debug("start clone with HV " + options.connect)

    if options.connect is None or options.connect.lower()[0:3] == "xen":
        if os.geteuid() != 0:
            print >> sys.stderr, _("Must be root to clone Xen guests")
            sys.exit(1)

    conn = libvirt.open(options.connect)
    design = clmgr.CloneDesign(connection=conn)

    try:    
        get_clone_diskfile(options.new_diskfile, design)
        get_clone_macaddr(options.new_mac, design)
        get_original_guest(options.original_guest, design)
        get_clone_name(options.new_name, design)
        get_clone_uuid(options.new_uuid, design)
        get_clone_sparse(options.sparse, design)
        get_force_target(options.target, design)
        get_preserve(options.preserve, design)

        # setup design object
        design.setup()

        # start cloning
        clmgr.start_duplicate(design)

        logging.debug("end clone")
    except Exception, e:
        print "ERROR: ", e
        sys.exit(1)

if __name__ == "__main__":
    main()

